def fracDeal (exp):
      """
Fraction Parsing Function : 
fracDeal (exp):
Description:-
Accepts an expression (exp), strips away the spaces in front of the expression, and sets it's 'prefactor' to be 1. If the expression describes a fraction, such as ' \\frac{t^{ab}_{kl} v^{kl}_{ij}}{2} ', which has a tensor contraction as it's numerator and an integer as it's denominator, it extracts the denominator from it (named prefactor), and cuts off the '\\frac{' and '}{2}' to yield the expression within, and returns the expression and the pre-factor as a list of size 2. If not, the stripped expression and it's prefactor (= 1) are returned as a list.
Parameters:-
exp : expression (a string)
What the function returns:-
A list containing a processed expression, and it's prefactor, in that order.
Exceptions:-
The function only accepts expressions of the format ' \\frac{some expression}{2} '. Thus, expressions like ' \\frac{some expression}{2  } ', ' \\frac  {t^{ab}_{kl} v^{kl}_{ij}}{2} ', ' 3*\\frac{...}{2} ' won't be rendered properly. In short, follow the template strictly, and avoid any extra spaces in it.

      """
      exp = exp.strip()
      prefact = 1.0
      if 'frac' in exp:
          prefact = float(exp[-2]) 
          exp = exp[6:-4]
      return exp, prefact

def generalDeal (exp):
      """
Single Permutation Dealing Function :
generalDeal (exp):
Description:-
Accepts an expression (exp), passes it through the fraction parsing function (fracDeal(exp)) to obtain the modified (ie:- any frac signs analysed and stripped away) expression containing only a contraction of tensor expressions and may be a SINGLE permutation of 2 indices, say 'f^{k}_{c} t^{c}_{i} t^{ab}_{jk} P(ij)'. If the permutation is there, two expressions are generated, and if it isn't, a single one is generated, the indices are lowered, and the modified expressions along with their prefactors are returned.
Parameters:-
exp : expression (a string)
What the function returns:-
A list of lists, each containing a processed expression, and it's prefactor, in that order.
Exceptions:-
The function only accepts expressions of the format ' \\frac{some expression P(ij)}{2} '. Thus, expressions like ' \\frac{some expression P(ij)   }{2} ', ' \\frac{some expression}{2  } ', ' \\frac  {t^{ab}_{kl} v^{kl}_{ij}}{2} ', ' 3*\\frac{...}{2} ' won't be rendered properly. In short, follow the template strictly, and avoid any extra spaces in it.

      """
      
      u = fracDeal(exp)
      prefactor = u[1]
      exp = u[0]
     
      retval = []
      if exp[-5] == 'P':
            
            c1 = exp[-3]
            c2 = exp[-2]
            c = '0' 
            newExp = exp.replace(c1,c).replace(c2,c1).replace(c,c2)
            exp = exp.replace('}_{','')
            exp = exp[:-6]
            
            retval.append([exp,prefactor])
            newExp = newExp[:-6]
            newExp = newExp.replace('}_{','')
            
            retval.append([newExp,prefactor])
            
      else :
            exp = exp.replace('}_{','')
            retval.append([exp,prefactor])
      
      return retval

def chop (string, index):
    """
String Chopping Function :
chop (string, index):
Description:-
Accepts a string and an index, and removes 6 characters in it, starting from the given index.
Parameters:-
string : string, index : index
What the function returns:-
A string with the desired part removed.
Exceptions:-
Take care to supply the proper index in the arguments.
    """
    return (string[:(index-1)] + string[(index+5):])

def biPermdeal (exp):

      """
Double Permutation Dealing Function :
biPermdeal (exp):
Description:-
Accepts an expression (with at most 2 permutations of 2 indices each), finds the indices of each 'P' symbol, chops them out one at a time (using chop (string, index)) so that the resulting expression has at most one permutation, such an expression is then processed using generalDeal (exp), and the resulting lists corresponding to each of the expressions generated by the permutations are then concatenated together to return a list of lists, where each list contains an expression and it's corresponding prefactor.
Parameters:-
exp : expression (a string)
What the function returns:-
A list of lists, where each list contains an expression and it's corresponding prefactor.
Exceptions:-
The function only accepts expressions of the format (an example is given for clarity)' \\frac{t^{c}_{i} t^{ad}_{jk} v^{bk}_{cd} P(ab) P(ij)}{2} '. Strictly follow this format, and avoid any extra spaces in it other than the ones already shown.
      """
     
      indexList = [i for i, c in enumerate(exp) if c == 'P']
      count = len(indexList)
      if count <= 1 :
          return generalDeal(exp)
      else :
          permlist = []
          retval = []
          for i in indexList:
              
              permlist.append(chop(exp,i))
          
          for term in permlist:
              for x in generalDeal(term):
                  retval.append(x)
          return retval

def generateEinsumString (indlist):
  """
Einsum string generating function : 
generateEinsumString (indlist):
Description:-
Accepts a list of indices, and generates from it a string (which is collated together from all the index strings, with appropriate punctuation marks, from indlist) which is the first argument in an einsum function.
Parameters:-
indlist : list of indices (each index is a string of alphabets)
What the function returns:-
A string 
Exceptions:-
The function accepts lists of the format ['b...i', 'ac...jk', 'jk...bc']. Within a string, before the alphabets, spaces make no difference. But don't give spaces in between the alphabets.
  """

  rev = ''   
  for c in indlist[0]:  
      rev = c + rev 
  indlist[0] = rev
  sep1 = ','
  sep2 = ''
  retval = sep1.join(indlist)
  retval = retval + '->'
  String = sep2.join(indlist)
  for i in String:
    count = 0
    for j in String:
        if i == j:
            count += 1
        if count > 1:
            break
    if count == 1:
        retval = retval + i


  return str(retval)


from collections import Counter

def nameTensors (tens, indlist):

    """
Tensor naming function : 
nameTensors (tens, indlist):
Description:-
Accepts a list of strings (mostly single alphabets) along with their corresponding list of indices, and depending upon:
If the corresponding string of indices for 't' in tens is of length 2 or 4, it's renamed to 't1' and 't2' respectively, and if the corresponding string of indices for 'r' in tens is of length 1 or 3, it's renamed to 'r1' and 'r2' respectively.
Parameters:-
tens : list of tensors (each tensor is a string of one or two alphabets), indlist : list of indices (each index is a string of alphabets)
What the function returns:-
An updated list (tens)
Exceptions:-
There could be an exception if the lengths of tens and indlist are unequal.
    """

    l = len(tens)
    for j in range(0,l):
        h = len(indlist[j])
        if tens[j] == 't' and h == 2:
                tens[j] = 't1'
        elif tens[j] == 't' and h == 4:
                tens[j] = 't2'
        elif tens[j] == 'r' and h == 1:
                tens[j] = 'r1'
        elif tens[j] == 'r' and h == 3:
                tens[j] = 'r2'
    return tens



def numpyStringBasic (exp, prf):

    """
Numpy command generating function :
numpyStringBasic (exp, prf):
Description:-
Accepts an expression exp, extracts the list of tensor names and their corresponding indices from them, generates the corresponding numpy strings using generateEinsumString (indlist) and nameTensors (tens, indlist), and then combines those strings together into a valid numpy command. Finally, 1/prf, a decimal, is coverted into a string literal and "multiplied along"  with the numpy command, as in 0.5*np.einsum('ia,ia->',f,g).
Parameters:-
exp : An expression, prf : A natural number
What the function returns:-
A string representing a numpy command
Exceptions:-
This function calls upon biPermDeal to convert the expression for further modification. Hence avoid any expressions which would also give an exception in biPermDeal.

    """
    
    exp = biPermdeal(exp)[0][0]
    exp = exp.replace('}_{','')
    List = exp.split()
    indices = []
    tensors = []
    for individual in List:
        indices.append(individual[individual.find('{') + 1:individual.rfind('}')])
        tensors.append(individual[:individual.find('^')])
    
    retval = """np.einsum('"""
    retval = retval + generateEinsumString(indices) + """',"""
    t = nameTensors(tensors,indices)
    l = len(t)-1
    for i in range(0,l):
          retval = retval + t[i] + ""","""
    retval = retval + t[l] + """)"""
    
    if prf != 1:
      coeff = str(1.0/prf)
      retval = coeff + """*""" + retval
    
    return retval

def numpyString (exp):
  """
Numpy command generating function, general :
numpyString (exp):
Description:-
Accepts an expression exp, extracts the all the expressions that could be produced from it (in case there are permutations) and their corresponding prefactors from them, generates the corresponding numpy strings using numpyStringBasic, and "adds them".
Parameters:-
exp : An expression
What the function returns:-
A string representing a numpy command
Exceptions:-
This function calls upon numpyStringBasic to convert the expression for further modification. Hence avoid any expressions which would also give an exception in numpyStringBasic.
  """
  prefix = fracDeal(exp)[1]
 
  l = len(biPermdeal(exp))
  if l >= 2 :
    retval = numpyStringBasic(exp, prefix) + """ + """
    for i in range(1,l):
        retval = retval + numpyStringBasic(biPermdeal(exp)[i][0], prefix) + """ + """
    return retval[:-3]
  else :
    return numpyStringBasic(exp, prefix)
