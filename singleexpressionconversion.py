def fracDeal (exp):
      """
Fraction Parsing Function : 
fracDeal (exp):
Description:-
Accepts an expression (exp), strips away the spaces in front of the expression, and sets it's 'prefactor' to be 1. If the expression describes a fraction, such as ' \\frac{t^{ab}_{kl} v^{kl}_{ij}}{2} ', which has a tensor contraction as it's numerator and an integer as it's denominator, it extracts the denominator from it (named prefactor), and cuts off the '\\frac{' and '}{2}' to yield the expression within, and returns the expression and the pre-factor as a list of size 2. If not, the stripped expression and it's prefactor (= 1) are returned as a list.
Parameters:-
exp : expression (a string)
What the function returns:-
A list containing a processed expression, and it's prefactor, in that order.
Exceptions:-
The function only accepts expressions of the format ' \\frac{some expression}{2} '. Thus, expressions like ' \\frac{some expression}{2  } ', ' \\frac  {t^{ab}_{kl} v^{kl}_{ij}}{2} ', ' 3*\\frac{...}{2} ' won't be rendered properly. In short, follow the template strictly, and avoid any extra spaces in it.
      """
      exp = exp.strip()
      prefact = 1.0
      if 'frac' in exp:
          prefact = float(exp[-2]) 
          exp = exp[6:-4]
      return exp, prefact
'''
The 3 functions below (chop, cutOut and switch) are helper functions for other functions.
'''

def chop (string, index):
  return (string[:(index-1)] + string[(index+5):])

def cutOut (string, index):
  return string[(index-1):(index+5)] 

def switch (s,i1,i2):
  dummy = '0' 
  return s.replace(i1,dummy).replace(i2,i1).replace(dummy,i2)

def uniPerm (exp):
  """
Single Permutation Dealing Function :
uniPerm (exp):
Description:-
Accepts an expression (exp), passes it through the fraction parsing function (fracDeal(exp)) to obtain the modified (ie:- any frac signs analysed and stripped away) expression containing only a contraction of tensor expressions and may be a SINGLE permutation of 2 indices, say 'f^{k}_{c} t^{c}_{i} t^{ab}_{jk} P(ij)'. If the permutation is there, two expressions are generated, and if it isn't, a single one is generated, the indices are lowered, and the modified expressions along with their prefactors (note that the prefactor of the swapped expression is the negative of the original expression) are returned.
Parameters:-
exp : expression (a string)
What the function returns:-
A list of lists, each containing a processed expression, and it's prefactor, in that order.
Exceptions:-
The function only accepts expressions of the format ' \\frac{some expression P(ij)}{2} '. Thus, expressions like ' \\frac{some expression P(ij)   }{2} ', ' \\frac{some expression}{2  } ', ' \\frac  {t^{ab}_{kl} v^{kl}_{ij}}{2} ', ' 3*\\frac{...}{2} ' won't be rendered properly. In short, follow the template strictly, and avoid any extra spaces in it.
  """
  u = fracDeal(exp)
  prefactor = u[1]
  exp = u[0]
  retval = []
  if exp[-5] == 'P':
            
            c1 = exp[-3]
            c2 = exp[-2]
            newExp = switch(exp,c1,c2)
            exp = exp.replace('}_{','')
            exp = exp[:-6]
            
            retval.append([exp,prefactor])
            newExp = newExp[:-6]
            newExp = newExp.replace('}_{','')
            
            retval.append([newExp,(-1)*prefactor])
            
  else :
            exp = exp.replace('}_{','')
            retval.append([exp,prefactor])
      
  return retval


def biPerm (exp):
  """
Double Permutation Dealing Function :
biPerm (exp):
Description:-
Accepts an expression (with at most 2 permutations of 2 indices each), finds the indices of each 'P' symbol, chops them out one at a time (using chop (string, index)) so that the resulting expression has at most one permutation, such an expression is then processed using uniPerm (exp) and the other helper functions defined above, and the resulting lists corresponding to each of the expressions generated by the permutations are then concatenated together to return a list of lists, where each list contains an expression and it's corresponding prefactor.
Parameters:-
exp : expression (a string)
What the function returns:-
A list of lists, where each list contains an expression and it's corresponding prefactor.
Exceptions:-
The function only accepts expressions of the format (an example is given for clarity)' \\frac{t^{c}_{i} t^{ad}_{jk} v^{bk}_{cd} P(ab) P(ij)}{2} '. Strictly follow this format, and avoid any extra spaces in it other than the ones already shown.
  """
  indexList = [i for i, c in enumerate(exp) if c == 'P']
  count = len(indexList)
  if count <= 1:
    return uniPerm(exp)
  elif count == 2:
    retval = [item for item in uniPerm(chop(exp,indexList[1]))]
    u = uniPerm(chop(exp,indexList[1]))
    c = cutOut(exp,indexList[1])
    u[0][0] = switch(u[0][0],c[-3],c[-2])
    u[1][0] = switch(u[1][0],c[-3],c[-2])
    u[0][1] *= (-1)
    u[1][1] *= (-1)
    retval.append(u[0])
    retval.append(u[1])
    return retval

def generateEinsumString (indlist):
  """
Einsum string generating function : 
generateEinsumString (indlist):
Description:-
Accepts a list of indices, and generates from it a string (which is collated together from all the index strings, with appropriate punctuation marks, from indlist) which is the first argument in an einsum function.
Parameters:-
indlist : list of indices (each index is a string of alphabets)
What the function returns:-
A string 
Exceptions:-
The function accepts lists of the format ['b...i', 'ac...jk', 'jk...bc']. Within a string, before the alphabets, spaces make no difference. But don't give spaces in between the alphabets.
  """

  retval = ','.join(indlist)
  retval = retval + '->'
  String = ''.join(indlist)
  rhs = ''
  for i in String:
    count = 0
    for j in String:
        if i == j:
            count += 1
        if count > 1:
            break
    if count == 1:
        rhs += i
  rhs = ''.join(sorted(rhs))
  retval += rhs

  return str(retval)

def transcribe (ind, mode):
    """
A helper function for nameTensors. Helps in naming the 'f' and 'v' tensors. Thus mode = 'f' or 'v'.
    """
    retval = ''
    for ite in ind:
        if ite < 'g':
            if mode == 'f':
                retval += 'a'
            elif mode == 'v':
                retval += 'v'
        else:
            if mode == 'f':
                retval += 'i'
            elif mode == 'v':
                retval += 'o'
    return retval


def nameTensors (tens, indlist):
    """
Tensor naming function : 
nameTensors (tens, indlist):
Description:-
Accepts a list of strings (mostly single alphabets) along with their corresponding list of indices, and depending upon:
If the corresponding string of indices for 't' in tens is of length 2 or 4, it's renamed to 't1' and 't2' respectively, and if the corresponding string of indices for 'r' in tens is of length 1 or 3, it's renamed to 'r1' and 'r2' respectively. v and f are named with the help of the transcribe function defined above.
Parameters:-
tens : list of tensors (each tensor is a string of one or two alphabets), indlist : list of indices (each index is a string of alphabets)
What the function returns:-
An updated list (tens)
Exceptions:-
There could be an exception if the lengths of tens and indlist are unequal.
    """
    for j in range(len(tens)):
        h = len(indlist[j])
        if tens[j] == 't':
            if h == 2:
               tens[j] = 't1'
            elif h == 4: 
               tens[j] = 't2'
        elif tens[j] == 'r':
            if h == 1:
               tens[j] = 'r1'
            elif h == 3: 
               tens[j] = 'r2'
        elif tens[j] == 'v':
            tens[j] = transcribe(indlist[j],'v')
        elif tens[j] == 'f':
            tens[j] = 'f' + transcribe(indlist[j],'f')

    return tens

def numpyStringBasic (exp, prf):
    """
Numpy command generating function :
numpyStringBasic (exp, prf):
Description:-
Accepts an expression exp, extracts the list of tensor names and their corresponding indices from them, generates the corresponding numpy strings using generateEinsumString (indlist) and nameTensors (tens, indlist), and then combines those strings together into a valid numpy command. Finally, the prefactor is divided (as in "/(prf)") with the numpy command.
Parameters:-
exp : An expression, prf : A natural number
What the function returns:-
A string representing a numpy command
Exceptions:-
This function calls upon biPerm to convert the expression for further modification. Hence avoid any expressions which would also give an exception in biPerm.
    """
    exp = uniPerm(exp)[0][0]
    exp = exp.replace('}_{','')
    List = exp.split()
    indices = []
    tensors = []
    for individual in List:
        indices.append(individual[individual.find('{') + 1:individual.rfind('}')])
        tensors.append(individual[:individual.find('^')])
    
    retval = """np.einsum('"""
    retval = retval + generateEinsumString(indices) + """',"""
    t = nameTensors(tensors,indices)
    l = len(t)-1
    for i in range(l):
          retval += t[i] + ""","""
    retval += t[l] + """)"""
    
    if prf != 1 and prf != -1:
      c = str(prf)
      retval += """/(""" + c + """)"""
    elif prf == -1:
      retval = """(-1)*""" + retval

    
    return retval

def numpyString (exp):
  """
Numpy command generating function, general :
numpyString (exp):
Description:-
Accepts an expression exp, extracts the all the expressions that could be produced from it (in case there are permutations) and their corresponding prefactors from them, generates the corresponding numpy strings using numpyStringBasic, and "adds them".
Parameters:-
exp : An expression
What the function returns:-
A string representing a numpy command
Exceptions:-
This function calls upon numpyStringBasic to convert the expression for further modification. Hence avoid any expressions which would also give an exception in numpyStringBasic.
  """
  prefix = fracDeal(exp)[1]
  l = len(biPerm(exp))
  if l >= 2 :
    initial = biPerm(exp)[0]
    retval = numpyStringBasic(initial[0], initial[1]) + """ + """
    for i in range(1,l):
        b = biPerm(exp)[i]
        retval += numpyStringBasic(b[0], b[1]) + """ + """
    return retval[:-3]
  else :
    return numpyStringBasic(exp, prefix)
